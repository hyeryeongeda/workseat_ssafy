# Javascript: Controlling Event — 요약 정리 (파트 1)

## 0. 표지

* 주제: **Javascript — Controlling event**
* 맥락: SSAFY / Python 트랙 중 JS 이벤트 제어 파트

---

## 1. 목차(슬라이드 기준)

* 이벤트

  * event
  * event object
  * event handler
* 버블링

  * 캡처링과 버블링
  * 버블링의 필요성
* event handler 활용

  * 이벤트 기본 동작 취소하기
* 참고

  * `addEventListener`와 화살표 함수 관계

---

## 2. 학습 목표(Objectives)

* `addEventListener`로 **이벤트 핸들러 등록**할 수 있다.
* 핸들러의 **event 객체**로 정보를 얻을 수 있다.
* **이벤트 버블링의 개념 / 전파 과정**을 설명할 수 있다.
* `event.target`과 `event.currentTarget`의 **차이**를 이해한다.
* 버블링을 이용해 **상위 요소에 이벤트 위임**을 구현한다.
* `event.preventDefault()`로 **요소의 기본 동작 취소**가 가능하다.
* **DOM 조작 + 이벤트**를 결합해 **동적인 웹**을 구현한다.

---

## 3. 이론 — 일상 속 이벤트

* 키보드 입력, 전화벨/수신, 손 흔들기(인사), 전화 버튼 누르기, 리모컨 채널 변경 등
* 핵심: **무언가의 ‘상호작용/변화’가 발생하는 시점**을 사건(Event)으로 본다.

---

## 4. 이론 — 웹에서의 이벤트

* 화면 스크롤, 버튼 클릭 시 팝업, 마우스 드래그 앤 드롭, 키보드 입력으로 요소 생성 등
* **거의 모든 상호작용은 이벤트와 함께** 일어난다.

---

## 5. event의 의미

* 정의: **웹 페이지 상에서 ‘무언가 일어났다’는 신호 또는 사건**
* 예시 비유: ‘영화 서비스’에서 포스터에 마우스를 올리면(이벤트), 시스템이 이를 **리스닝**하고 작은 이미지·설명(핸들링)이 나타나는 것
* 클릭/입력/변경 등 다양한 행위가 모두 이벤트에 해당

---

## 6. DOM 요소와 이벤트

* 모든 **DOM 요소는 다양한 형태의 이벤트를 발생**시킬 수 있음

  * 예) `button` 클릭 → `click` 이벤트
  * `input` 값 변경 → `input` 이벤트 등
* DOM 요소: **HTML 문서의 각 태그로부터 생성된 객체**

---

## 7. event object / event handler 개념

* DOM 요소에서 **event가 발생**하면,
* 연결된 **이벤트 처리기(event handler)** 가 **event 객체**를 인자로 받아 동작함

  * *event handler* = 특정 이벤트가 발생할 때 실행되는 **콜백 함수**
  * *event object* = 이벤트에 대한 **정보를 담은 객체**(발생 위치, 타입, 키/마우스 좌표 등)

---

## 8. 핵심 키워드 미리 보기

* `addEventListener(type, handler[, options])`
* `event.type`, `event.target`, `event.currentTarget`
* 버블링 vs 캡처링, **이벤트 위임**(delegation)
* `preventDefault()`, `stopPropagation()`

---

## 9. 미니 예고 — 코드 스니펫(다음 파트에서 상세)

```html
<button id="buy">Buy</button>
<script>
  const btn = document.getElementById('buy')
  btn.addEventListener('click', (event) => {
    // event: MouseEvent
    console.log(event.type)           // 'click'
    console.log(event.target === btn) // true
  })
</script>
```

---

### 참고 링크(개념 복습)

* MDN: addEventListener, Event, EventTarget, DOM 이벤트 흐름

> 다음 슬라이드가 도착하면 **버블링/캡처링, 기본 동작 취소, 위임**을 중심으로 이어서 정리합니다.

---

## 10. event handler

* 정의: **특정 이벤트가 발생했을 때 실행되는 콜백 함수**
* 보통 `addEventListener`를 통해 **DOM 요소에 등록**한다.

```js
function handleClick (event) {
  // 필요한 로직
}
btn.addEventListener('click', handleClick)
```

---

## 11. `addEventListener()`

* 역할: **지정한 이벤트가 발생하면 실행할 핸들러를 등록**하는 메서드.
* 형식: `EventTarget.addEventListener(type, handler[, options])`

  * `type`: `'click'`, `'input'`, `'mouseover'` 같은 **이벤트 이름(문자열)**
  * `handler`: 이벤트 발생 시 호출될 **콜백 함수**

---

## 12. `addEventListener()` 예시

```js
const button = document.querySelector('button')

// 이벤트 핸들러
const handleClick = function () {
  window.alert('버튼이 클릭 되었습니다!')
}

// 버튼의 click 이벤트에 핸들러를 등록
button.addEventListener('click', handleClick)
```

포인트: **핸들러(함수)** 와 **리스너 등록(메서드 호출)** 을 분리해 읽기 쉽게 유지.

---

## 13. 이벤트 등록 — 시그니처 복습

```txt
EventTarget.addEventListener(type, handler)
```

* **DOM 요소**가 `EventTarget`이며, 해당 요소가 **리스너**가 된다.
* `type`은 **수신할 이벤트**, `handler`는 **실행할 콜백**.

---

## 14. addEventListener 구조 상세

* `type`: 수신할 **이벤트 유형(문자열)**
* `handler`: 호출될 **콜백 함수**, **반환값 없음**
* 콜백은 **자동으로 event 객체를 첫 번째 매개변수**로 받는다.

```js
element.addEventListener('click', function (event) {
  // 이벤트 처리 로직
})
```

---

## 15. 이벤트 객체(event) 전달

* 이벤트 발생 시, **event 객체**가 핸들러의 **첫 인자**로 전달됨.
* 이 객체로 **발생 요소, 타입, 좌표, 추가 데이터** 등에 접근.

```html
<button id="btn">버튼</button>
<script>
  const btn = document.querySelector('#btn')
  const detectClick = function (event) {
    console.log(event)        // PointerEvent
    console.log(event.type)   // "click"
  }
  btn.addEventListener('click', detectClick)
</script>
```

---

## 16. 핸들러에서의 `this`

* 일반 함수 핸들러에서 `this`는 **리스너가 연결된 요소**를 가리킴 → `event.currentTarget`과 동일.

```js
const btn = document.querySelector('#btn')
const detectClick = function (event) {
  console.log(event.currentTarget) // <button id="btn">…
  console.log(this)                // 동일 요소
}
btn.addEventListener('click', detectClick)
```

> *화살표 함수의 `this`는 다르게 동작* (레퍼런스는 이후 참고 파트에서 정리)

---

## 17. 버블링 개요 (1/2)

* 중첩 구조 `form > div > p` 각각에 클릭 핸들러가 있을 때, **`p`를 클릭하면 모두 동작**.
* 이유는 **이벤트가 하위 → 상위로 전파**되기 때문.

---

## 18. 버블링 개요 (2/2)

* 콘솔 결과: `p → div → form` 순서로 로그 출력.
* 즉, 하위에서 발생한 이벤트가 **부모, 조상 요소로 올라가며** 각 핸들러를 차례로 트리거.

---

## 19. 버블링 정의와 팁

* **버블링(Bubbling)**: 한 요소에서 이벤트 발생 시, 해당 요소 핸들러가 실행된 뒤 **부모 요소들**의 핸들러가 **문서 최상단(document)까지 반복 실행**되는 현상.
* 예시 결과 순서: `p` 클릭 → `p` → `div` → `form`.
* **TIP**: "물이 거슬러 올라가듯" **가장 깊은 곳에서 시작해 바깥으로 전파**되므로 버블링이라 부른다.

---

## 20. `event.currentTarget` vs `event.target`

* **currentTarget**: *현재* 실행 중인 핸들러가 **연결된 요소**. 일반 함수 핸들러의 `this`와 같음.
* **target**: 이벤트가 **가장 안쪽에서 실제로 시작된 요소**. 버블링이 진행돼도 변하지 않음.

> 정리: *어디에 달아놨는지* → `currentTarget`, *어디서 발생했는지* → `target`.

---

## 21. `target` & `currentTarget` 예시 (개념)

* 세 박스(`outerouter > outer > inner`) 중 **최상위(outerouter)** 에만 핸들러를 등록.
* 어떤 박스를 클릭해도 이벤트가 **버블링되어 최상위**에 연결된 핸들러가 실행.
* 이때 콘솔에서 `event.target`과 `event.currentTarget`의 차이를 확인.

---

## 22. `target` & `currentTarget` 예시 (동작 설명)

* 핸들러는 `outerouter`에만 있지만, `outer`나 `inner`를 클릭해도 **동일한 핸들러**가 동작.
* 이유: 클릭 이벤트가 **버블링**되어 `outerouter`까지 전파되기 때문.

---

## 23. `target` & `currentTarget` 예시 (코드)

```html
<div id="outerouter">
  outerouter
  <div id="outer">
    outer
    <div id="inner">inner</div>
  </div>
</div>
<script>
  const outerOuterElement = document.querySelector('#outerouter')
  const clickHandler = function (event) {
    console.log('currentTarget:', event.currentTarget.id) // 'outerouter'
    console.log('target      :', event.target.id)         // 클릭된 실제 박스 id
  }
  outerOuterElement.addEventListener('click', clickHandler)
</script>
```

---

## 24. 캡처링(capturing)

* 흐름: **최상위 조상 → 타깃까지 아래로 전파(캡처링)** → 타깃에서 실행 → **다시 위로(버블링)**.
* 실무에서는 **버블링 위주**로 다루지만, 필요 시 캡처링 리스너를 설정 가능.

```js
doc.addEventListener('click', handler, { capture: true })
// 또는 세 번째 인자에 true
```

> 팁: 캡처링은 특수 제어가 필요할 때만. 기본은 버블링으로 충분.

---

## 25. 버블링이 필요한 이유 (1/2) — 이벤트 위임

* 버튼이 여러 개일 때 **각 버튼에 모두 핸들러를 달 필요 없음**.
* 공통 조상(예: `div`)에 **단 한 개의 핸들러**를 달고, `event.target`으로 **어떤 버튼인지 식별**.

---

## 26. 버블링이 필요한 이유 (2/2) — 효율성/유지보수

* 장점

  * **성능/메모리 절약**: 리스너 수 감소
  * **동적 요소 대응**: 나중에 추가된 버튼도 자동 처리
  * **코드 단순화**: 한 곳에서 분기 처리

```html
<div id="btn-wrap">
  <button data-act="save">Save</button>
  <button data-act="delete">Delete</button>
</div>
<script>
  const wrap = document.querySelector('#btn-wrap')
  wrap.addEventListener('click', (e) => {
    const btn = e.target.closest('button')
    if (!btn) return
    switch (btn.dataset.act) {
      case 'save':   /* ... */ break
      case 'delete': /* ... */ break
    }
  })
</script>
```

---

## 27. Event handler 활용 — 실습 목록

1. 클릭하면 숫자 1씩 증가
2. 입력 값을 실시간 출력
3. 입력 실시간 출력 + 버튼 클릭 시 스타일 변경
4. TODO 프로그램
5. 로또 번호 생성기

---

## 28. 실습 #1 — click 이벤트 (카운터)

```html
<button id="btn">버튼</button>
<p>클릭횟수: <span id="counter">0</span></p>
<script>
  let counterNumber = 0
  const btn = document.querySelector('#btn')
  const span = document.querySelector('#counter')
  const clickHandler = function () {
    counterNumber += 1
    span.textContent = counterNumber
  }
  btn.addEventListener('click', clickHandler)
</script>
```

---

## 29. 실습 #2 — input 이벤트 (실시간 출력)

```html
<input type="text" id="text-input" />
<p id="view"></p>
<script>
  const inputTag = document.querySelector('#text-input')
  const pTag = document.querySelector('#view')
  const inputHandler = function (event) {
    // event.currentTarget === inputTag
    pTag.textContent = event.currentTarget.value
  }
  inputTag.addEventListener('input', inputHandler)
</script>
```

---

## 30. `currentTarget` 주의사항

* `console.log(event)`로 전체 객체만 찍으면 `currentTarget`이 **null**처럼 보일 수 있음 → **실행 중인 순간**에만 유효하기 때문.
* 따라서 필요한 값은 **`console.log(event.currentTarget)`로 바로 확인**.
* `currentTarget` 이후의 세부 속성이 필요하면 보통 **`target`을 참고**해 판단.

---

## 31. 실습 #3 — click & input 결합

* 입력값을 **실시간 출력**하고, 버튼 클릭 시 **출력 요소의 스타일을 토글**.

```html
<h1 id="title">hello</h1>
<button id="btn">강조</button>
<input type="text" id="text-input" />
<style>
  .blue { color: blue; }
</style>
<script>
  const inputTag = document.querySelector('#text-input')
  const h1Tag = document.querySelector('#title')
  const btn = document.querySelector('#btn')

  const inputHandler = (e) => {
    h1Tag.textContent = e.currentTarget.value
  }
  inputTag.addEventListener('input', inputHandler)

  const clickHandler = () => {
    h1Tag.classList.toggle('blue')
  }
  btn.addEventListener('click', clickHandler)
</script>
```

---

## 32. 실습 #4 — TODO (1/2)

* 인풋 + `+` 버튼 클릭 시, **리스트에 항목 추가**.

```html
<input type="text" class="input-text" />
<button id="btn">+</button>
<ul id="list"></ul>
<script>
  const inputTag = document.querySelector('.input-text')
  const btn = document.querySelector('#btn')
  const ulTag = document.querySelector('#list')

  const addTodo = function () {
    const data = inputTag.value
    const li = document.createElement('li')
    li.textContent = data
    ulTag.appendChild(li)
    inputTag.value = ''
  }
  btn.addEventListener('click', addTodo)
</script>
```

---

## 33. 실습 #4 — TODO (2/2) 품질 개선

* **빈 문자열 방지** 및 **경고 처리**.

```js
const addTodo = function () {
  const data = inputTag.value
  if (data.trim()) {
    const li = document.createElement('li')
    li.textContent = data
    ulTag.appendChild(li)
    inputTag.value = ''
  } else {
    alert('할 일을 입력하세요…')
  }
}
```

---

## 34. 실습 #5 — 로또 번호 생성기

* 버튼 클릭 시 **6자리 난수**를 생성하여 리스트에 추가.
* 예시는 **lodash**를 이용해 난수/추출을 간편화.

```html
<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
<button id="btn">행운 번호 받기</button>
<div id="result"></div>
<script>
  const btn = document.querySelector('#btn')
  const result = document.querySelector('#result')
  const pickLotto = () => {
    // 1~45 범위에서 6개 랜덤 추출 후 정렬
    const nums = _.sampleSize(_.range(1, 46), 6).sort((a,b)=>a-b)
    const ul = document.createElement('ul')
    nums.forEach(n => {
      const li = document.createElement('li')
      li.textContent = n
      ul.appendChild(li)
    })
    result.appendChild(ul)
  }
  btn.addEventListener('click', pickLotto)
</script>
```

---

## 35. lodash 소개

* 배열/객체 **처리 유틸리티** 라이브러리.
* 모듈성·성능·추가 기능 제공. 랜덤 샘플링, 깊은 복사, 컬렉션 변환 등 유용.
* 참고: [https://lodash.com/](https://lodash.com/)

---

## 36. 이벤트의 기본 동작 취소

* 어떤 요소들은 **기본 동작**이 있음.

  * 예) `<form>` 제출 시 페이지 새로고침, `<a>` 클릭 시 링크 이동
* 필요 시 `event.preventDefault()`로 **기본 동작을 막고** 원하는 로직 수행.

---

## 37. `preventDefault()`

* 의미: 해당 이벤트에 대한 **기본 동작 실행을 중지**.
* 실무 예: 뒤로가기/링크 클릭으로 **입력 내용이 날아가는 것 방지**, 커스텀 제출 처리 등.

---

## 38. 기본 동작 취소 — 실습 목록

1. **copy** 이벤트 동작 취소
2. **form 제출 시 새로고침 방지**

---

## 39. 실습 — copy 이벤트 막기

```html
<h1>중요한 내용</h1>
<script>
  const h1Tag = document.querySelector('h1')
  h1Tag.addEventListener('copy', function (event) {
    event.preventDefault()
    alert('복사할 수 없습니다.')
  })
</script>
```

---

## 40. 실습 — form 제출 새로고침 방지

```html
<form id="my-form">
  <input type="text" name="username">
  <button type="submit">Submit</button>
</form>
<script>
  const formTag = document.querySelector('#my-form')
  const handleSubmit = function (event) {
    event.preventDefault() // 기본 제출 동작 차단
    // TODO: 검증/비동기 요청 등 원하는 로직 실행
  }
  formTag.addEventListener('submit', handleSubmit)
</script>
```

---

## 41. addEventListener에서의 화살표 함수 주의

* **화살표 함수는 자체 `this`가 없다.** 선언된 상위 스코프의 `this`를 그대로 사용.
* 리스너에서 화살표를 쓰면 `this`가 대개 **전역(window)** 를 가리키게 됨.
* 해결책

  * 일반 함수(`function`)를 쓰고 `this` 사용
  * 또는 **항상** `event.currentTarget`을 참조

```js
element.addEventListener('click', function () {
  console.log(this) // <button ...>
})

element.addEventListener('click', () => {
  console.log(this) // window (원치 않는 값)
})
```

---

## 42. 확인 문제 (객관식)

1. 특정 이벤트가 발생했을 때 실행되는 함수는? → **이벤트 핸들러**
2. DOM 요소에 이벤트 핸들러를 등록하는 메서드는? → **addEventListener**
3. 한 요소의 이벤트가 부모로 전파되는 현상은? → **버블링**
4. 핸들러에 자동 전달되는 첫 번째 인자는? → **event 객체**
5. `event.target`이 가리키는 대상? → **이벤트가 처음 발생한 요소**
6. `event.currentTarget`이 가리키는 대상? → **이벤트 핸들러가 연결된 요소**
7. 요소의 기본 동작을 막는 메서드? → **preventDefault()**
8. 버블링의 이점을 활용하는 주요 패턴? → **이벤트 위임**
9. 버블링 vs 캡처링 차이? → **버블링=하향→상향 전파, 캡처링=상향→하향 전파**
10. `target` vs `currentTarget`? → **target=실제 발생 요소, currentTarget=리스너 부착 요소**

---

## 43. 핵심 키워드 표 (요약)

| 개념                  | 설명                    | 예시                                    |
| ------------------- | --------------------- | ------------------------------------- |
| 이벤트(event)          | 웹페이지에서 일어나는 신호/사건     | `click`, `input`                      |
| 이벤트 핸들러             | 이벤트 발생 시 실행되는 콜백      | `btn.addEventListener('click', func)` |
| addEventListener    | DOM 요소에 이벤트 핸들러 등록    | 동일                                    |
| 이벤트 버블링             | 하위→상위로 전파되어 상위 핸들러 동작 | 하위 클릭 시 상위도 동작                        |
| event.target        | 실제 이벤트가 시작된 요소        | `console.log(event.target)`           |
| event.currentTarget | 핸들러가 연결된 요소           | `console.log(event.currentTarget)`    |
| preventDefault      | 기본 동작 취소              | `event.preventDefault()`              |

---

## 44. 오늘 공부한 내용 — 총정리

* **이벤트/이벤트 객체/이벤트 핸들러** 기본 개념
* `addEventListener(type, handler)` 사용법과 구조
* **버블링과 캡처링**, `target` vs `currentTarget`
* **이벤트 위임** 패턴과 장점
* `preventDefault()`로 **기본 동작 차단** + 실습 예제들

---

## 45. 비유 복습 — 카페 시나리오

* 손님의 주문(클릭/입력)이 **이벤트**
* 주문을 받는 키오스크가 **이벤트 리스너**
* 커피를 만드는 바리스타의 행동이 **이벤트 핸들러**

```js
const button = document.querySelector('#order-btn')
function makeCoffee (event) {
  console.log('커피 제조 시작', event)
}
button.addEventListener('click', makeCoffee)
```

---

## 40. 실습 — form 제출 시 새로고침 방지

```html
<form id="my-form">
  <input type="text" name="username" />
  <button type="submit">Submit</button>
</form>
<script>
  const formTag = document.querySelector('#my-form')
  const handleSubmit = function (event) {
    event.preventDefault() // 기본 제출(새로고침) 막기
    // 여기에 검증/비동기 요청 등 커스텀 로직
  }
  formTag.addEventListener('submit', handleSubmit)
</script>
```

---

## 41. `addEventListener`와 화살표 함수의 `this`

* **화살표 함수는 자체 `this`가 없음** → 상위 스코프의 `this`를 그대로 사용.
* 핸들러로 화살표 함수를 쓰면 `this`가 대개 **`window`**가 되어 버림.
* 해결: ① **일반 함수** 사용 or ② **`event.currentTarget`** 사용.

```js
// 권장 1) 일반 함수
el.addEventListener('click', function () {
  console.log(this) // 클릭된 요소
})

// 권장 2) 화살표 + currentTarget
el.addEventListener('click', (e) => {
  console.log(e.currentTarget) // 클릭된 요소
})
```

---

## 42. 확인 문제 (요약)

1. 특정 이벤트 발생 시 실행되는 함수? → **이벤트 핸들러**
2. DOM 요소에 이벤트 핸들러 등록 메서드? → **`addEventListener()`**
3. 하위 → 상위로 전파되는 현상? → **버블링**
4. 핸들러에 자동 전달되는 첫 번째 인자? → **`event` 객체**
5. `event.target`은? → **이벤트가 처음 발생한 요소**
6. `event.currentTarget`은? → **핸들러가 연결된 요소**
7. 기본 동작을 막는 메서드? → **`preventDefault()`**
8. 버블링 이점을 활용하는 주요 패턴? → **이벤트 위임**
9. 버블링 vs 캡처링 차이? → **버블링=상향, 캡처링=하향 전파**
10. `target` vs `currentTarget`? → **발생 요소 vs 리스너 부착 요소**

---

## 43. 활동 정리 — 핵심 키워드 표

| 개념                  | 설명                | 예시                                    |
| ------------------- | ----------------- | ------------------------------------- |
| 이벤트(event)          | 웹에서 일어나는 신호/사건    | `click`, `input`                      |
| 이벤트 핸들러             | 이벤트 발생 시 실행될 콜백   | `btn.addEventListener('click', func)` |
| addEventListener    | DOM 요소에 핸들러 등록    | 동일                                    |
| 이벤트 버블링             | 하위 → 상위 핸들러 순차 실행 | 하위 클릭 시 상위도 동작                        |
| event.target        | 실제 이벤트 시작 요소      | `console.log(event.target)`           |
| event.currentTarget | 핸들러가 연결된 요소       | `console.log(event.currentTarget)`    |
| preventDefault      | 기본 동작 취소          | `event.preventDefault()`              |

---

## 44. 오늘 배운 내용 — 요약

* **이벤트 / event 객체 / 핸들러 / addEventListener 시그니처**
* **버블링/캡처링 흐름** 및 **위임 패턴**
* **`target` vs `currentTarget`** 구분
* **기본 동작 취소(`preventDefault`)**와 실습들(click/input, TODO, 로또, copy, form)

---

## 45. 비유로 이해하기 (카페)

* 손님의 ‘주문’이 **이벤트**
* 주문을 받는 키오스크가 **이벤트 리스너**
* 주문에 맞게 커피를 만드는 바리스타의 동작이 **이벤트 핸들러**

---

## 46. 실무 팁 & 체크리스트

* 핸들러에서 `this`가 필요하면 **일반 함수**를 쓰거나 **`event.currentTarget`** 사용
* 동적으로 생성되는 다수의 자식 요소 처리 ⇒ **이벤트 위임**
* 링크/폼 커스텀 처리 ⇒ **`preventDefault()` + 검증/비동기**
* 전파 제어가 필요하면 **`event.stopPropagation()`**도 고려(버블링 차단)
* 디버깅: **`type/target/currentTarget/defaultPrevented`** 확인 습관
